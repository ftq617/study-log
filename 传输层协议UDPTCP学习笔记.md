### UDP
1. 特点
    * 无连接
        * 数据直接放送，不需要建立连接和释放连接。应用层通过端口获取数据，如果接收端没有该端口进程，那么直接将数据包丢弃。
    * 面向报文
        * 对应用层传递的报文，直接加上首部就传递给IP层，传输层不分包，一次之传输一个报文；不过IP层可能会分包。交付也是一样，直接打包好传递给应用层。所以这里需要注意一下传递的报文不能太大，太大会让IP层对数据分片，就要传输更多的IP首部； 当然也不能太小，太小的话传输效率就会很底下。
    * 尽最大可能交付
        * 没有确认机制、重传机制。数据只管发送，不管接收方是否接收到了，是否来得及接收。
    * 一对一、一对多、多对一、多对多交互
    * 没用拥塞控制
        * 因为没用确认机制，重传机制，所以UDP 无法知道网络的具体情况、以及接收端的接收能力。自然也就没有了拥塞控制
    * 报文首部开销小。只有八个字节
2. 首部
    UDP 报文由两部分组成，首部和数据部分。
    ``` 
    |----------------------------------------------------------------|
    | 源端口 （2字节） | 目的端口（2字节）| 长度（2字节）| 校验和（2字节）|
    |----------------------------------------------------------------|
                            UDP报文首部
    ```
    首部组成:
    * 源端口（2字节）：数据发送端的端口
    * 目的端口（2字节）：数据接收端的端口
    * 长度（2字节）：次数据报文长度（包括首部），最小值为 8 ，仅有首部。
    * 校验和（2字节）：用来校验数据包数据是否正确，错误的话直接丢弃
    ```
        | ----------------------------------------------------------------------------------------------------|
        |源IP地址（4字节）| 目的IP地址（4字节） | 0（1字节 ，默认为0）| 17（1位，标识为 UDP报文）| UDP报文长度（2位）|
        |-----------------------------------------------------------------------------------------------------|
                                               IP 首部 （伪首部）
    ```
    * 校验方式：在 UDP 报文之前加上 IP的首部（效果如下图只在计算校验和的时候加上，其它时间不会加，所以这个叫伪首部）。然后校验和字段 放入全 0，最后将伪首部和UDP报文 每 16位为一个值切分，最后一个值不足16位的话就在后面补全0。然后将切分下来的值进行反码运算求和。得出的值就是校验和。
    * 校验目的：这样既校验了数据及数据端口的正确性，还校验了报文 IP的正确性
    
     ![](https://s3.bmp.ovh/imgs/2021/10/f49cec8cb6698386.jpeg)

3. 思考
    1. 因为 UDP 没有拥塞控制，如果网络情况不好的话，UDP连接很多，那很容易把网络撑爆。这个还是需要注意一下
    2. 因为无连接，首部小的特点；UDP 比较适合数据实时性强、准确性底的场景。比如实时视频、实时通话等场景
### TCP
1. 特点
    * 面向连接：传输之前需要建立稳定连接（虚拟连接，只是和对方约定我们需要一起传输数据了），传输完成还需要断开连接；通过套接字来标识一个连接，IP：端口 为套接字。一个套接字只能有一个TCP连接，但是一个IP可以有多个 TCP连接，一个端口也可以有多个TCP连接。
    * 可靠交付：传输的数据必须是无差错、不丢失、不重复、有序到达
    * 双向通信：建立好连接后，发送端也是接收端，服务端和客户端都可以发送和接受数据
    * 面向字节流：不同于UDP 是把应用层传递的数据整个打包发出去。TCP 只将应用层传递下来的数据看作一个无结构的字节流，并将字节流根据不同情况打包成指定大小的数据报文发送。TCP不需要了解传输数据是什么东西，只知道传输的是字节，应用层传递下来的是什么字节，就将该字节完整的传输到接收端，由接收端的应用层来解析还原成数据原本的结构
2. 传输过程
    网络连接是很不稳定的，数据可能会在半路上因为种种原因而丢失。
    * 稳定传输的原理
        * 报文确认：为了确保数据正确的从发送端到达接收端，接收端需要告诉发送端，自己收到了那些报文。
            * 注意事项：如果报文中途丢失或者迟到了，会有两种情况，
                1. 发送端没有收到确认报文，那么报文进行超时重传，接收端又收到了该报文，报文丢弃，但还是需要传送确认报文。
                2. 发送端重传后收到两次确认报文，直接丢弃多收到的报文
        * 超时重传：如果发送端迟迟没有收到某一报文的确认信息，那么就认为数据发送失败，就需要重新发送该报文，直到收到报文的确认信息为止。
            * 注意事项：
                1. 需要为每一个报文都设置一个超时计时器
                2. 需要为每一个报文设置序号，用来确认那个报文发送成功，那个失败
                3. 发送端发送报文后，数据不能马上删掉释放缓存，需要保留一段时间，直到收到确认信息后才能释放。
    * 重传时间计算
        * 往返时间 RTT : 正常未重传阶段，发送报文到接收到确认报文的时间
        * 加权平均往返时间 RTTs : 
            * 第一次取就取RTT
            * 后续为： RTTs = (1 - x) * RTTs + x * RTT(最新样本)    [RFC 6298 推荐 x 取值为0.125]
        * 偏差加权平均值 RTTd
            * 第一次为 RTT的一半
            * 后续为： RTTd = (1 - y) * RTTd + y * |RTTs - RTT（最新样本）|  [推荐值 y 为 0.25]  
        * 超时重传时间 RTO = RTTs + 4 * RTTd
        * 注意：
            * 重传时间需要好好考量，而且要能根据当前网络情况来实时更新，而且要数据报文的往返时间要大，否则会造成不必要的重传，网络上会有一堆的重传数据包，从而撑爆网络降低传输效率。
            * 重传时间不能太低，否则网络资源会一直处于空闲阶段，造成资源浪费
            * 重传的确认报文会影响 RTT 的计算，会有以下影响:
                1. 收到的确认报文是第一次的，但是被当作是重传的确认报文，则RTT计算偏小，RTO计算偏小
                2. 收到确认报文是重传的，但是被当作第一次的确认报文，则RTT计算偏大，RTO计算偏大
                3. 解决方案：针对重传报文的RTT计算时间，不计入RTO的计算，但是每重传一次，RTO 为原来的两倍，直到不再重传了，继续用原来的方式计算
    * 批量传输：
        * TCP　并不是发送一个报文后需要收到确认报文再发送第二个报文，这样很明显就可以看出传输效率很低下，不过不可否这种方式执行起来是最简单的。
        * TCP的做法是一次性发送多个报文,接收端并不用为每个报文都回复确认，只需要回复有序收到的最大的那个报文序号。这样做的好处是实现简单，而且可以充分利用网络信道，并减少确认报文的传输，缺点是 如果1,2,3,4,5报文传输，接收端只收到1,2,4,5, 那接收端只会回复确认报文 2，那么4，5报文可能会因为长时间没有收到确认而被超时重传。
            
3. 首部 有20字节是固定的，后面有4n 字节是根据需要可以自己增加的选项，所以头部最小字节是20 字节（具体如下图） 

    ![](https://s3.bmp.ovh/imgs/2021/10/7b7edcc6c0f7f711.jpg)
    * 源端口（2字节）
    * 目的端口（2字节）
    * 发送序号（4字节）:发送那个的字节序号，每发送一个字节，序号加1，用来告知接收端这是第几端内容，开始建立连接时可以自己选择值，后面需要根据发送情况来增加
        * 注意：最大值是 2^32 -1 就是4,294,967,296个序号，用完了之后变成0，继续往上加，如果传输数据量大，且还很快，那么接收端序号可能会有重复的，这个时候就要根据头部选项的时间搓（10字节）来判断是否重复报文以及确定顺序
    * 确认号（4字节）:希望下一次接受的字节序号，表示 该字节序号之前的数据都正常接受到了。下一次传输的发送序号用这个值。仅当 ACK 为1 时，这个字段才起作用
    * 数据偏移(4位)：首部长度，单位为4字节
    * 保留（6位）
    * URG
    * ACK
    * PSH
    * SYN
    * FIN
    * 窗口
    * 校验和
    * 紧急指针
    * 选项
    
4. 流量控制（滑窗）
    * 实现原理
    * 作用
5. 拥塞控制
    * 满开始
    * 拥塞避免
    * 快重传
    * 快恢复
6. TCP连接，三次握手
7. TCP释放，四次挥手

### TCP 和 UDP 的 区别

### 思考
1. 滑窗中接收方收到报文乱序时，如报文段a,b,c,d,e,f,g 发送后接收方只收到 a,b,d,e,f,g。为什么确认报文返回的是b；为什么不把的d,e,f,g的确认报文返回
2. TCP有超时重传机制，那么对于重复的数据包在TCP 连接存在时，和TCP 断开时会做什么处理？
    
