### UDP
1. 特点
    * 无连接
        * 数据直接放送，不需要建立连接和释放连接。应用层通过端口获取数据，如果接收端没有该端口进程，那么直接将数据包丢弃。
    * 面向报文
        * 对应用层传递的报文，直接加上首部就传递给IP层，传输层不分包，一次之传输一个报文；不过IP层可能会分包。交付也是一样，直接打包好传递给应用层。所以这里需要注意一下传递的报文不能太大，太大会让IP层对数据分片，就要传输更多的IP首部； 当然也不能太小，太小的话传输效率就会很底下。
    * 尽最大可能交付
        * 没有确认机制、重传机制。数据只管发送，不管接收方是否接收到了，是否来得及接收。
    * 一对一、一对多、多对一、多对多交互
    * 没用拥塞控制
        * 因为没用确认机制，重传机制，所以UDP 无法知道网络的具体情况、以及接收端的接收能力。自然也就没有了拥塞控制
    * 报文首部开销小。只有八个字节
2. 首部
    UDP 报文由两部分组成，首部和数据部分。
    ``` 
    |----------------------------------------------------------------|
    | 源端口 （2字节） | 目的端口（2字节）| 长度（2字节）| 校验和（2字节）|
    |----------------------------------------------------------------|
                            UDP报文首部
    ```
    首部组成:
    * 源端口（2字节）：数据发送端的端口
    * 目的端口（2字节）：数据接收端的端口
    * 长度（2字节）：次数据报文长度（包括首部），最小值为 8 ，仅有首部。
    * 校验和（2字节）：用来校验数据包数据是否正确，错误的话直接丢弃
    ```
        | ----------------------------------------------------------------------------------------------------|
        |源IP地址（4字节）| 目的IP地址（4字节） | 0（1字节 ，默认为0）| 17（1字节，标识为 UDP报文）| UDP报文长度（2字节）|
        |-----------------------------------------------------------------------------------------------------|
                                               IP 首部 （伪首部）
    ```
    * 校验方式：在 UDP 报文之前加上 IP的首部（效果如下图只在计算校验和的时候加上，其它时间不会加，所以这个叫伪首部）。然后校验和字段 放入全 0，最后将伪首部和UDP报文 每 16位为一个值切分，最后一个值不足16位的话就在后面补全0。然后将切分下来的值进行反码运算求和。得出的值就是校验和。
    * 校验目的：这样既校验了数据及数据端口的正确性，还校验了报文 IP的正确性
    
     ![](https://s3.bmp.ovh/imgs/2021/10/f49cec8cb6698386.jpeg)

3. 思考
    1. 因为 UDP 没有拥塞控制，如果网络情况不好的话，UDP连接很多，那很容易把网络撑爆。这个还是需要注意一下
    2. 因为无连接，首部小的特点；UDP 比较适合数据实时性强、准确性底的场景。比如实时视频、实时通话等场景
### TCP
1. 特点
    * 面向连接：传输之前需要建立稳定连接（虚拟连接，只是和对方约定我们需要一起传输数据了），传输完成还需要断开连接；通过套接字来标识一个连接，IP：端口 为套接字。一个套接字只能有一个TCP连接，但是一个IP可以有多个 TCP连接，一个端口也可以有多个TCP连接。
    * 可靠交付：传输的数据必须是无差错、不丢失、不重复、有序到达
    * 双向通信：建立好连接后，发送端也是接收端，服务端和客户端都可以发送和接受数据
    * 面向字节流：不同于UDP 是把应用层传递的数据整个打包发出去。TCP 只将应用层传递下来的数据看作一个无结构的字节流，并将字节流根据不同情况打包成指定大小的数据报文发送。TCP不需要了解传输数据是什么东西，只知道传输的是字节，应用层传递下来的是什么字节，就将该字节完整的传输到接收端，由接收端的应用层来解析还原成数据原本的结构
2. 传输过程
    网络连接是很不稳定的，数据可能会在半路上因为种种原因而丢失。
    * 稳定传输的原理
        * 报文确认：为了确保数据正确的从发送端到达接收端，接收端需要告诉发送端，自己收到了那些报文。
            * 注意事项：如果报文中途丢失或者迟到了，会有两种情况，
                1. 发送端没有收到确认报文，那么报文进行超时重传，接收端又收到了该报文，报文丢弃，但还是需要传送确认报文。
                2. 发送端重传后收到两次确认报文，直接丢弃多收到的报文
        * 超时重传：如果发送端迟迟没有收到某一报文的确认信息，那么就认为数据发送失败，就需要重新发送该报文，直到收到报文的确认信息为止。
            * 注意事项：
                1. 需要为每一个报文都设置一个超时计时器
                2. 需要为每一个报文设置序号，用来确认那个报文发送成功，那个失败
                3. 发送端发送报文后，数据不能马上删掉释放缓存，需要保留一段时间，直到收到确认信息后才能释放。
    * 重传时间计算
        * 往返时间 RTT : 正常未重传阶段，发送报文到接收到确认报文的时间
        * 加权平均往返时间 RTTs : 
            * 第一次取就取RTT
            * 后续为： RTTs = (1 - x) * RTTs + x * RTT(最新样本)    [RFC 6298 推荐 x 取值为0.125]
        * 偏差加权平均值 RTTd
            * 第一次为 RTT的一半
            * 后续为： RTTd = (1 - y) * RTTd + y * |RTTs - RTT（最新样本）|  [推荐值 y 为 0.25]  
        * 超时重传时间 RTO = RTTs + 4 * RTTd
        * 注意：
            * 重传时间需要好好考量，而且要能根据当前网络情况来实时更新，而且要数据报文的往返时间要大，否则会造成不必要的重传，网络上会有一堆的重传数据包，从而撑爆网络降低传输效率。
            * 重传时间不能太低，否则网络资源会一直处于空闲阶段，造成资源浪费
            * 重传的确认报文会影响 RTT 的计算，会有以下影响:
                1. 收到的确认报文是第一次的，但是被当作是重传的确认报文，则RTT计算偏小，RTO计算偏小
                2. 收到确认报文是重传的，但是被当作第一次的确认报文，则RTT计算偏大，RTO计算偏大
                3. 解决方案：针对重传报文的RTT计算时间，不计入RTO的计算，但是每重传一次，RTO 为原来的两倍，直到不再重传了，继续用原来的方式计算
    * 批量传输：
        * TCP　并不是发送一个报文后需要收到确认报文再发送第二个报文，这样很明显就可以看出传输效率很低下，不过不可否这种方式执行起来是最简单的。
        * TCP的做法是一次性发送多个报文,接收端并不用为每个报文都回复确认，只需要回复有序收到的最大的那个报文序号。这样做的好处是实现简单，而且可以充分利用网络信道，并减少确认报文的传输，缺点是 如果1,2,3,4,5报文传输，接收端只收到1,2,4,5, 那接收端只会回复确认报文 2，那么4，5报文可能会因为长时间没有收到确认而被超时重传。
            
3. 首部 有20字节是固定的，后面有4n 字节是根据需要可以自己增加的选项，所以头部最小字节是20 字节（具体如下图） 

    ![](https://s3.bmp.ovh/imgs/2021/10/7b7edcc6c0f7f711.jpg)
    * 源端口（2字节）
    * 目的端口（2字节）
    * 发送序号（4字节）:发送那个的字节序号，每发送一个字节，序号加1，用来告知接收端这是第几端内容，开始建立连接时可以自己选择值，后面需要根据发送情况来增加
        * 注意：最大值是 2^32 -1 就是4,294,967,296个序号，用完了之后变成0，继续往上加，如果传输数据量大，且还很快，那么接收端序号可能会有重复的，这个时候就要根据头部选项的时间搓（10字节）来判断是否重复报文以及确定顺序
    * 确认号（4字节）:希望下一次接受的字节序号，表示 该字节序号之前的数据都正常接受到了。下一次传输的发送序号用这个值。仅当 ACK 为1 时，这个字段才起作用
    * 数据偏移(4位)：首部长度，单位为4字节， 最大长度 2^4 - 1 = 15 ,15 * 4 = 60，说明一个TCP 报文的首部最长只能是 60个字节。选项中 的4n n的最大值是10
    * 保留（6位） ：给以后用的，目前是全0
    * URG（1位）：与紧急指针配合使用，如果为1，说明应用层有紧急数据，需要将紧急数据放到报文发送队列最前端，最先发送，且不受窗口值影响。
    * ACK（1位）：确认位，为1时 确认号 字段值起作用。连接建立后所有的报文此字段都要为1，只有申请建立连接、申请断开连接时，此字段才为0
    * PSH（1位）：推送，这个字段为 1 时，发送端会立马将此报文发出，然后接收端需要立马处理交付到应用层，不需要等缓存区满了再交付
    * SYN（1位）：连接位，这个字段为 1 时说明这是个连接握手报文
    * FIN（1位）：释放位，这个字段为 1 时说明这是个断开连接的报文
    * 窗口（2字节）： 用来告诉发送端，从确认后开始，接收端现在还可接收多少字节数据；发送端目前只能从确认号开始发送指定大小字节数。用来控制发送端的发送速率，而且值是会变化的。
    * 校验和（2字节）： 和UDP一样，只是要将伪首部中的协议号由 17 变成 6，UDP长度变成 TCP长度
    * 紧急指针（2字节）：只有在 URG为1时起作用，表示从数据头开始后面多少字节是紧急数据，其它的就是普通数据
    * 选项：长度可变，最少 0，最大 40字节，目前现有规定的值有：
        * 最大报文段长度 MSS (Max Segment Size),只是TCP数据段长度，不包含首部 默认值是536字节，实际情况是双方通过此字段告知传输时最大的数据报文大小，因为不同的传输链路对IP层的分片规则是不一样的。
        * 窗口增大选项（3字节）：因为窗口字段只有两字节，最大值只是 2^16 - 1 = 64K,这个大小在如今可能不太够，此字段需要在连接建立时一起协商。
        * 时间戳（10字节）：用来计算往返时间，以及确保 发送序号相同的包是否同一个数据包，以及到达的顺序
            * 时间戳值（4字节）：存储发送时间戳
            * 时间戳回送回答（4字节）：确认报文用来存储接受到报文的时间戳
   
4. 流量控制（滑窗）效果如下图 灰色部分为窗口

    ![](https://s3.bmp.ovh/imgs/2021/10/16e976ef8cfa3dca.jpg) 
    * 目的：充分利用网络通道发送数据的同时，还能让接收端来的及接收数据，通过控制发送端的发送速率来保护接收端可以及时接收并处理数据。
    * 实现原理：使用一个窗口来限制发送端在当前确认号之后还可以发送多少数据，并通过接收方返回的窗口字段动态调整这个窗口大小。(效果如上图)
    * 注意：
        * 如果发送端收到一个窗口值为0的确认报文，这个时候发送端就不会再发送数据了，需要等接收端有空余空间了就会返回新的不为0的窗口值给发送端，这个时候发送端又可以发送数据了，这里需要注意一下，如果接受端发送的窗口值不为0的报文在传输过程中丢失了那么就会造成一个 发送端不发数据，接收端等数据的情况，为了解决这个问题，TCP会为每个连接都建立一个持续计时器，只要收到了窗口值为0的报文就启动这个计时器，如果计时器时间到了没有反应发送端就会发送一个探测报文，只有一个字节数据，然后接收端收到报文就会返回当前最新的窗口值，如果为0就刷新计时器继续等待，如果不为0那么就发送新数据。
        * 发送端和接收端都各有 一个 发送窗口 和 接收窗口
5. 拥塞控制 这里要补充两个属性，拥塞窗口（cwnd），慢开始门限（ssthresh）
    * 目的：因为网络链路的原因，网络中可能接受不了那么多数据包，比如路由器的数据队列满了等，一般我们认为如果报文超时重传了，就认为网络发生了拥堵，那么只能控制流入到网络层的数据包来缓解网络传输压力（通过cwnd 来控制）
    * 实现：
        * 慢开始： 第一次发送一个数据报文，之后每收到一次确认报文cwnd就加 1（2的指数增大），直到加到大于等于ssthresh时，就采用拥塞避免算法
        * 拥塞避免：每一批次传输结束后 窗口值就加 1 （线性扩大）；
            * 如果发现这中间有超时的数据包，TCP就会认为网络有拥塞，需要做出控制，则 ssthresh = cwnd / 2,cwnd 变为 1，这样就进入到了慢开始阶段
        * 快重传：可能会有些网络环境让数据包在传输途中丢失了，导致收不到确认报文，从而让TCP误以为网络发生了堵塞，所以需要避免一下
            * 接收段收到报文就立马回复确认包，当然这里回复的是有序收到的最大序号，如果连续三次收到一样的序号，就认为接收方没有收到此报文，那么就立刻重传此报文，这样就不会出现超时了，发送方也不会认为网络拥堵了
        * 快恢复：进行快重传后并不进入到慢开始，而是进行快恢复，ssthresh = cwnd / 2,同时 cwnd = ssthresh,这样就开始启动 拥塞避免算法
    * 注意： TCP 的发送窗口大小取值 等于 Min(首部窗口字段值,拥塞窗口（cwnd）)
        * 网络层策略：当路由器数据队列达到一个百分值时，对新收到的收据包会计算一个概率来判断是否丢弃。这样可以避免 数据队列满了的时候拒绝掉所有的TCP连接，而是让一部分TCP连接可以正常使用，另一部分挂掉，可以减缓网络层的压力，分批次处理任务。
6. TCP连接，三次握手
7. TCP释放，四次挥手

### TCP 和 UDP 的 区别
1. TCP 是面向连接，可靠传输，有拥塞控制，UDP 正好相反
2. TCP 是一对一双向通信，UDP 是一对一、一对多、多对一、多对多 单向通信 
3. TCP 面向字节流、UDP面向报文
    
### 思考
1. 滑窗中接收方收到报文乱序时，如报文段a,b,c,d,e,f,g 发送后接收方只收到 a,b,d,e,f,g。为什么确认报文返回的是b；为什么不把的d,e,f,g的确认报文返回
    * 如果这样做，确认报文会比较多，而且就为了传输一个确认序号，就要带上20个字节TCP首部和20个IP协议首部，以及数据链路层、物理层等，会造成网络资源浪费，而且还要处理确认报文丢失的情况重传的包就更多了，有一种策略是可以在选项中加上 一个范围确认的字段，这样就可以减少确认报文的产生了，不过目前没有人使用
2. TCP有超时重传机制，那么对于重复的数据包在TCP 连接存在时、TCP 断开时会做什么处理？
    * 连接状态下，直接丢弃重传的数据包
    * 断开情况下普通数据包是直接丢弃，但是有一种情况是 如果客户端第一次申请连接超时，发起了了第二次申请连接，然后成功了并且通信后关闭了连接，这个时候第一次申请连接的数据包它到达了服务端，那么还是会正常的走三次握手过程，这个时候服务端会向客户端发送连接确定数据包，这里可以扩展下为什么要第三次握手，如果没有第三次握手，那么这个时候服务端就会以为和 客户端建立连接成功了，就会在等客户端发送数据，然而实际情况是客户端压根就没和服务端创立连接，所以只有服务端在干等，造成了资源浪费。
    
