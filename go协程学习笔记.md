### Go协程学习笔记
1. 什么是协程
    * 大家知道的：进程是资源调度的最小单位、线程是CPU最小的调度单位；那么协程就是比线程还要轻量级的一个运行单位，他有自己的栈。简单的说，它属于用户级线程，依赖系统线程执行，但是可以自己调度
2. 和线程的区别
    * 虽然线程的出现，提升了系统CPU复用、减少了资源调度的问题。但是计算机发展到今天，还是会有以下几点问题：
        * 一个线程要占好几兆内存，如果程序不加以控制，那么高并发下，服务器瞬间就会内存不足（这就是为什么会有线程池）
        * 线程是由操作系统负责调度的，我们无法控制，这样就需要花很多精力去解决线程的同步调用问题
        * 线程的创建、销毁、调度都要占用CPU的资源，频繁的切换会影响程序性能
    * 协程是属于用户级线程，它依托系统线程运行，但是可以由程序控制调用，且占用资源非常小。简单讲可以理解成是升级版的线程，可以优化上述线程出现的问题。（为什么是优化？因为协程占的内存和调度消耗的资源比线程小非常多，所以是优化）
    * 简单来讲，协程就是利用系统线程按照我们特定的顺序来运行指定的功能代码，和JAVA线程池的实现有些类似。
3. go 协程的 GMP调度思想、和实现
    * 为了方便描述，下面我们统一用如下称呼来描述协程、线程、调度器
    ![](https://ftp.bmp.ovh/imgs/2020/08/1cc63565c17cd8fc.png)
    * 学过JAVA线程池的都知道，线程池有任务队列、工作线程。go早期的调度器和这种模式相似(模型图如下)，由一个全局协程队列和若干个工作线程组成，但是这样的设计会有一些问题：
    ![](https://s3.bmp.ovh/imgs/2021/10/fcb03244a9843333.png)
        * 各协程之间要创建、销毁、获取协程都需要抢占队列锁资源，这样竞争会非常激烈，如果是纯计算型任务，就不能最大化利用CPU资源
        * 协程的关系性会变差，比如 协程a,在线程e中运行，如果协程a创建了协程b，理论上协程b也应该在线程e中运行，但是目前来看有可能会在线程f中运行
        * 各线程之间调度切换还是会消耗很多系统资源
   
    * GMP的设计（模型图如下）
    ![](https://ftp.bmp.ovh/imgs/2020/08/315f12a08fbb4ffa.jpg)
        * 全局队列
        * 调度器P的本地队列
        * 调度器P
        * 线程M
        
    * GMP的工作流程
    ![](https://s3.bmp.ovh/imgs/2021/10/19026cc16314e876.jpeg)
4. 与java线程池的对比
    JAVA 线程池是任务绑定线程后的，只有执行完任务才会释放线程，只有完成了一个任务才会释放线程去执行新的任务，而协程是调度器绑定线程，G 任务可以在一个线程上切换调度，所以协程的任务切换成本会比 线程池低，所以协程在数据型密集的系统上并发效率更高。如果是IO型密集的系统上，一个IO就会堵塞一个线程，这种情况协程也是要切换一个空闲线程或者新创建一个线程的，切换成本和 线程池是一样的，所以差距就不那么大了。
5. 小结
