### Go协程学习笔记
1. 什么是协程
    * 大家知道的：进程是资源调度的最小单位、线程是CPU最小的调度单位；那么协程就是比线程还要轻量级的一个运行单位，他有自己的栈。简单的说，它属于用户级线程，依赖系统线程执行，但是可以自己调度
2. 和线程的区别
    * 虽然线程的出现，提升了系统CPU复用、减少了资源调度的问题。但是计算机发展到今天，还是会有以下几点问题：
        * 一个线程要占好几兆内存，如果程序不加以控制，那么高并发下，服务器瞬间就会内存不足（这就是为什么会有线程池）
        * 线程是由操作系统负责调度的，我们无法控制，这样就需要花很多精力去解决线程的同步调用问题
        * 线程的创建、销毁、调度都要占用CPU的资源，频繁的切换会影响程序性能
    * 协程是属于用户级线程，它依托系统线程运行，但是可以由程序控制调用，且占用资源非常小。简单讲可以理解成是升级版的线程，可以优化上述线程出现的问题。（为什么是优化？因为协程占的内存和调度消耗的资源比线程小非常多，所以是优化）
    * 简单来讲，协程就是利用系统线程按照我们特定的顺序来运行指定的功能代码，和JAVA线程池的实现有些类似。
3. go 协程的 GMP调度思想、和实现
    * 为了方便描述，下面我们统一用如下称呼来描述协程、线程、调度器
    <img src="https://static.studygolang.com/200225/6bdb04101cc63565c17cd8fcaba17321.png">    
    * 学过JAVA线程池的都知道，线程池有任务队列、工作线程。go早期的调度器和这种模式相似(模型图如下)，由一个全局协程队列和若干个工作线程组成，但是这样的设计会有一些问题：
        <img src="https://static.studygolang.com/200225/bdcdc5e6fcb03244a9843333cca62378.png">
        * 各线程之间要创建、销毁、获取协程都需要抢占队列锁资源，这样竞争会非常激烈，如果是纯计算型任务，就不能最大化利用CPU资源
        * 协程的关系性会变差，比如 协程a,在线程e中运行，如果协程a创建了协程b，理论上协程b也应该在线程e中运行，但是目前来看有可能会在线程f中运行
        * 各线程之间调度切换还是会消耗很多系统资源
   
    * GMP的设计（模型图如下）
    <img src="https://static.studygolang.com/200225/ebfe3e28315f12a08fbb4ffaee32e046.png" > 
        * 全局队列
        * 调度器P的本地队列
        * 调度器P
        * 线程M
        
    * GMP的工作流程
        <img src="https://static.studygolang.com/200225/764f7be119026cc16314e87628e4013f.jpeg" > 
4. 与java线程池的对比
5. 小结